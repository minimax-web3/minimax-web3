{"extracted_information": "This document provides a guide on creating NFTs on the Solana blockchain using the Metaplex Token Metadata protocol. It covers initial setup, required packages, Umi setup, image and metadata uploading, and minting NFTs (both standard and programmable).", "specifications": {}, "pricing": {}, "features": ["Creation of NFTs on the Solana blockchain using the Metaplex Token Metadata protocol.", "Supports both standard NFTs and Programmable NFTs (pNFTs).", "Utilizes Umi framework for Solana development.", "Includes image and metadata uploading to Arweave via Irys uploader.", "Provides code examples for each step of the process."], "statistics": {}, "temporal_info": {}, "geographical_data": {}, "references": ["Metaplex Token Metadata Program", "Umi Documentation", "Arweave"], "Metaplex Token Metadata Program": {"description": "A program on the Solana blockchain that defines the metadata for tokens, including NFTs.", "key_features": ["Standardized metadata format for NFTs.", "Support for royalties and programmable behavior (pNFTs).", "Integration with various Solana wallets and marketplaces."]}, "Solana NFT Creation Process": {"steps": ["Set up a Solana development environment with Node.js and the required packages.", "Initialize a new project and install dependencies.", "Configure Umi with a wallet and RPC connection.", "Upload the NFT image to Arweave using Irys uploader.", "Create and upload the NFT metadata to Arweave.", "Mint the NFT using either the `createNft` (for standard NFTs) or `createProgrammableNft` (for pNFTs) instruction."]}, "JavaScript SDK Usage": {"key_packages": ["@metaplex-foundation/umi", "@metaplex-foundation/umi-bundle-defaults", "@metaplex-foundation/mpl-token-metadata", "@metaplex-foundation/mpl-core", "@solana/spl-token", "@metaplex-foundation/umi-uploader-irys"], "umi_setup": "Create Umi instance and configure it with the desired RPC endpoint, Token Metadata program, and Irys uploader.", "wallet_setup": "Generate a new wallet or use an existing wallet by loading the keypair from a file.", "nft_minting": "Use `createNft` or `createProgrammableNft` functions to mint NFTs."}, "NFT vs pNFT Differences": {"nft": {"royalty_enforcement": "No royalty enforcement.", "complexity": "Simpler in initial setup and to work with in future."}, "pnft": {"royalty_enforcement": "Royalty enforcement.", "complexity": "More accounts to deal with when it comes to future development.", "programmability": "Programmable with rulesets that can block programs from making a transfer."}}, "Dependencies and Configurations": {"dependencies": ["@metaplex-foundation/umi", "@metaplex-foundation/umi-bundle-defaults", "@metaplex-foundation/mpl-token-metadata", "@metaplex-foundation/mpl-core", "@solana/spl-token", "@metaplex-foundation/umi-uploader-irys", "Node.js 18.x.x or above"], "configurations": ["Umi setup with RPC endpoint (e.g., devnet-aura.metaplex.com)", "Wallet configuration (newly generated or existing keypair)", "Irys uploader configuration with Arweave endpoint (e.g., devnet.irys.xyz)"]}, "Testnet Setup Requirements": {"rpc_endpoint": "Use a devnet RPC endpoint (e.g., devnet-aura.metaplex.com).", "airdrop": "Airdrop SOL to the wallet for transaction fees.", "keypair": "Use a devnet keypair for testing."}, "code_examples": [{"title": "Initializing", "code": "npm init"}, {"title": "Required Packages", "code": "npm i @metaplex-foundation/umi\nnpm i @metaplex-foundation/umi-bundle-defaults\nnpm i @metaplex-foundation/mpl-token-metadata\nnpm i @metaplex-foundation/umi-uploader-irys;"}, {"title": "Imports and Wrapper Function", "code": "import{ createProgrammableNft, mplTokenMetadata }from\"@metaplex-foundation/mpl-token-metadata\";import{  createGenericFile,  generateSigner,  percentAmount,  signerIdentity,  sol,}from\"@metaplex-foundation/umi\";import{ createUmi }from\"@metaplex-foundation/umi-bundle-defaults\";import{ irysUploader }from\"@metaplex-foundation/umi-uploader-irys\";import{ base58 }from\"@metaplex-foundation/umi/serializers\";import fs from\"fs\";import path from\"path\";\n\n// Create the wrapper function\nconstcreateNft=async()=>{/////////  all our code will go in here//////}// run the wrapper function\ncreateNft()"}, {"title": "Setting up Umi - Generating a New Wallet", "code": "const umi =createUmi(\"https://devnet-aura.metaplex.com/<YOUR_API_KEY>\").use(mplTokenMetadata()).use(irysUploader({// mainnet address: \"https://node1.irys.xyz\"// devnet address: \"https://devnet.irys.xyz\"      address:\"https://devnet.irys.xyz\",}));// Generate a new keypair signer.\nconst signer =generateSigner(umi)// Tell umit to use the new signer.\numi.use(signerIdentity(signer))// This will airdrop SOL on devnet only for testing.\nawait umi.rpc.airdrop(umi.identity.publickey)"}, {"title": "Use an Existing Wallet", "code": "const umi =createUmi(\"https://devnet-aura.metaplex.com/<YOUR_API_KEY>\").use(mplTokenMetadata()).use(irysUploader({// mainnet address: \"https://node1.irys.xyz\"// devnet address: \"https://devnet.irys.xyz\"      address:\"https://devnet.irys.xyz\",}));// Generate a new keypair signer.\nconst signer =generateSigner(umi)// You will need to us fs and navigate the filesystem to// load the wallet you wish to use via relative pathing.\nconst walletFile =const imageFile = fs.readFileSync(    path.join(__dirname,'./keypair.json'))"}, {"title": "Uploading the Image", "code": "// use `fs` to read file via a string path.\n// You will need to understand the concept of pathing from a computing perspective.\nconst imageFile = fs.readFileSync(\n  path.join(__dirname,'..','/assets/my-image.jpg'))// Use `createGenericFile` to transform the file into a `GenericFile` type// that umi can understand. Make sure you set the mimi tag type correctly// otherwise Arweave will not know how to display your image.\nconst umiImageFile =createGenericFile(imageFile,'my-image.jpeg',{\n  tags:[{ name:'Content-Type', value:'image/jpeg'}],\n})// Here we upload the image to Arweave via Irys and we get returned a uri// address where the file is located. You can log this out but as the// uploader can takes an array of files it also returns an array of uris.// To get the uri we want we can call index [0] in the array.\nconst imageUri =await umi.uploader.upload([umiImageFile]).catch((err)=>{thrownewError(err)})\nconsole.log(imageUri[0])"}, {"title": "Uploading the Metadata", "code": "// Call upon umi's uploadJson function to upload our metadata to Arweave via Irys.\nconst metadata ={\"name\":\"My NFT\",\"description\":\"This is an NFT on Solana\",\"image\": imageUri[0],\"external_url\":\"https://example.com/my-nft.json\",\"attributes\":[{\"trait_type\":\"trait1\",\"value\":\"value1\"},{\"trait_type\":\"trait2\",\"value\":\"value2\"}],\"properties\":{\"files\":[{\"uri\": imageUri[0],\"type\":\"image/png\"}],\"category\":\"image\"}}\nconst metadataUri =await umi.uploader.uploadJson(metadata).catch((err)=>{thrownewError(err)})"}, {"title": "NFT Minting", "code": "// We generate a signer for the Nft\nconst nftSigner =generateSigner(umi)\nconst tx =awaitcreateNft(umi,{\n  mint: nftSigner,\n  sellerFeeBasisPoints:percentAmount(5.5),\n  name:'My NFT',\n  uri: metadataUri,\n}).sendAndConfirm(umi)// finally we can deserialize the signature that we can check on chain.\n// import { base58 } from \"@metaplex-foundation/umi/serializers\";\nconsole.log(base58.deserialize(tx.signature)[0])"}, {"title": "pNFT Minting", "code": "// We generate a signer for the NFT\nconst nftSigner =generateSigner(umi)// Decide on a ruleset for the Nft.\n// Metaplex ruleset - publicKey(\"eBJLFYPxJmMGKuFwpDWkzxZeUrad92kZRC5BJLpzyT9\")// Compatability ruleset - publicKey(\"AdH2Utn6Fus15ZhtenW4hZBQnvtLgM1YCW2MfVp7pYS5\")\nconst ruleset =null// or set a publicKey from above\nconst tx =awaitcreateProgrammableNft(umi,{\n  mint: nftSigner,\n  sellerFeeBasisPoints:percentAmount(5.5),\n  name:'My NFT',\n  uri: metadataUri,\n  ruleSet: ruleset,\n}).sendAndConfirm(umi)// finally we can deserialize the signature that we can check on chain.\n// import { base58 } from \"@metaplex-foundation/umi/serializers\";\nconsole.log(base58.deserialize(tx.signature)[0])"}, {"title": "Full Code Example", "code": "import{ createProgrammableNft }from'@metaplex-foundation/mpl-token-metadata'\nimport{\n  createGenericFile,\n  generateSigner,\n  percentAmount,\n  publicKey,\n  signerIdentity,\n  sol,\n}from'@metaplex-foundation/umi'\nimport{ createUmi }from'@metaplex-foundation/umi-bundle-defaults'\nimport{ base58 }from'@metaplex-foundation/umi/serializers'\nimportfsfrom'fs'\nimportpathfrom'path'\n\nconstcreateNft=async()=>{\n\n//// ** Setting Up Umi **//\nconst umi =createUmi(\"https://devnet-aura.metaplex.com/<YOUR_API_KEY>\").use(mplTokenMetadata()).use(irysUploader({// mainnet address: \"https://node1.irys.xyz\"// devnet address: \"https://devnet.irys.xyz\"\naddress:\"https://devnet.irys.xyz\",}));\n\nconst signer =generateSigner(umi);\n  umi.use(signerIdentity(signer));\n\n// Airdrop 1 SOL to the identity\n// if you end up with a 429 too many requests error, you may have to use\n// the filesystem wallet method or change rpcs.\nconsole.log(\"Airdropping 1 SOL to identity\");\nawait umi.rpc.airdrop(umi.identity.publicKey,sol(1));\n\n//// ** Upload an image to Arweave **//\n\n//// use `fs` to read file via a string path.\n// You will need to understand the concept of pathing from a computing perspective.\nconst imageFile = fs.readFileSync(\n    path.join(__dirname,\"../assets/images/0.png\"));\n\n// Use `createGenericFile` to transform the file into a `GenericFile` type\n// that umi can understand. Make sure you set the mimi tag type correctly\n// otherwise Arweave will not know how to display your image.\nconst umiImageFile =createGenericFile(imageFile,\"0.png\",{tags:[{name:\"Content-Type\",value:\"image/png\"}],});\n\n// Here we upload the image to Arweave via Irys and we get returned a uri\n// address where the file is located. You can log this out but as the\n// uploader can takes an array of files it also returns an array of uris.\n// To get the uri we want we can call index [0] in the array.\nconsole.log(\"Uploading image...\");\nconst imageUri =await umi.uploader.upload([umiImageFile]).catch((err)=>{\nthrownewError(err);\n});\n\n//// ** Upload Metadata to Arweave **//\nconst metadata ={\nname:\"My Nft\",\ndescription:\"This is an Nft on Solana\",\nimage: imageUri[0],\nexternal_url:\"https://example.com\",\nattributes:[\n{trait_type:\"trait1\",value:\"value1\",},\n{trait_type:\"trait2\",value:\"value2\",},\n],\nproperties:{\nfiles:[{uri: imageUri[0],type:\"image/jpeg\",},\n],\ncategory:\"image\",\n},\n};\n\n// Call upon umi's uploadJson function to upload our metadata to Arweave via Irys.\nconsole.log(\"Uploading metadata...\");\nconst metadataUri =await umi.uploader.uploadJson(metadata).catch((err)=>{\nthrownewError(err);\n});\n\n//// ** Creating the Nft **//\n\n//// We generate a signer for the Nft\nconst nftSigner =generateSigner(umi);\n\n// Decide on a ruleset for the Nft.\n// Metaplex ruleset - publicKey(\"eBJLFYPxJmMGKuFwpDWkzxZeUrad92kZRC5BJLpzyT9\")\n// Compatability ruleset - publicKey(\"AdH2Utn6Fus15ZhtenW4hZBQnvtLgM1YCW2MfVp7pYS5\")\nconst ruleset =null\n// or set a publicKey from above\nconsole.log(\"Creating Nft...\");\nconst tx =awaitcreateProgrammableNft(umi,{\nmint: nftSigner,\nsellerFeeBasisPoints:percentAmount(5.5),\nname: metadata.name,\nuri: metadataUri,\nruleSet: ruleset,\n}).sendAndConfirm(umi);\n\n// Finally we can deserialize the signature that we can check on chain.\nconst signature = base58.deserialize(tx.signature)[0];\n\n// Log out the signature and the links to the transaction and the NFT.\nconsole.log(\"\\npNFT Created\")\nconsole.log(\"View Transaction on Solana Explorer\");\nconsole.log(`https://explorer.solana.com/tx/${signature}?cluster=devnet`);\nconsole.log(\"\\n\");\nconsole.log(\"View NFT on Metaplex Explorer\");\nconsole.log(`https://explorer.solana.com/address/${nftSigner.publicKey}?cluster=devnet`);\n\n}\n\ncreateNft()"}]}